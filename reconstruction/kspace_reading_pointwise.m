function [ksP,rsP] = kspace_reading_pointwise(raw_data_fid,fid_file,param)
%% kspace_reading_xcorr2
% This function reads the kspace of an EPIP experiment from a .fid varian 
% file. It then performs the correction of the kspace with a cross
% correlation algorithm to correct the odd and even echoes mismatch.
% Finally, it performs a fourier transform to obtain the real space image.
% It can then compare those images to the .fid generated by varian and/or
% save the images in a .nii file.

% param fields (default value):
% param.data (1): specifies if the data used should be the raw Eplus and Eminus
% images or the intertwined images IprimeP and IprimeN

% param.save_nii (1): specifies if the data should be saved in a .nii files

% param.xcorr_type (1): specifies the type of correlation to be used.
% 1: Correct odd and even echoes mismatch with the central columns of each scan
% 2: Correct odd and even echoes mismatch with the 2 most correlated odd/even columns of each scan
% 3: Correct odd and even echoes mismatch individually for each column

% param.center_kspace (2): specifies the type of kspace centering to be
% applied before the cross correlation
% 0: no centering
% 1: 1D centering (only in the frequency direction)
% 2: 2D centering

% param.nx (64): Must specify the number of lines in the frequency direction

% param.ny (64): Must specify the number of lines in the phase direction

% param.display (1): Specifies if the data should be displayed or not

% param.fdf_comp (1): Specifies if the fdf data should be readed and
% compared

% param.vol_pour (1): specifies the pourcentage of volumes to be
% kept and analysed. 1=all the volumes. 0=only the first volume

%% Parameter verification
if ~exist(fid_file,'file')
    errordlg('Cannot find the fid_file')
end
field_names={'data','save_nii','xcorr_type','center_kspace','nx','ny','display','fdf_comp' 'vol_pour'};
default_values=[1 1 1 2 64 64 1 1 1];
field_verif = isfield(param,field_names);
if ~isempty(find(field_verif,1));
    default_fields = find(field_verif==0);
    for i=default_fields
        param.(field_names{i})=default_values(i);
        % param = setfield(param,field_names{i},default_values(i));
    end
end

%% 1. Collect a reference scan, R+, with phase encode  gradient off 

% 2. Reverse the even echoes
disp('2. Reverse the even echoes');
Rplus = raw_data_fid.Rplus;
Rplus(1:param.knx,2:2:end,:) = raw_data_fid.Rplus(param.knx:-1:1,2:2:end,:);
% imagesc(abs(Rplus(:,:,4)));

% 3. FT along the read dimension 
disp('3. FT along the read dimension');
for z=1:param.knz
    for y=1:param.ny
        fftRplus(:,y,z) = fftshift(ifft(Rplus(:,y,z)));
    end
end
if param.display
    z=4;
    figure('Name','Rplus')
    subplot(1,3,1); imagesc(abs(Rplus(:,:,4))); title('Rplus')
    subplot(1,3,2); imagesc(abs(fftRplus(:,:,z))); title('fftRplus')
    subplot(1,3,3); imagesc(angle(fftRplus(:,:,z))); title('angle of fftRplus')
end
% 4. Determine the phase, P+, of each data point 
disp('4. Determine the phase, P+, of each data point ');
% mean_fftRplus = mean(abs(fftRplus(:)));
% fftRplus(abs(fftRplus)<mean_fftRplus) = 0;
Pplus = angle(fftRplus);

% 5. Collect the EPI data, E+

% 6. Reverse the even echoes
disp('6. Reverse the even echoes');
Eplus = raw_data_fid.Eplus;
Eplus(1:param.knx,2:2:end,:,:) = raw_data_fid.Eplus(param.knx:-1:1,2:2:end,:,:);

% 7. FT the EPI data along the read dimension 
disp('7. FT the EPI data along the read dimension ');
for t=1:param.nt
    for z=1:param.knz
        for y=1:param.ny
            fftEplus(:,y,z,t) = fftshift(ifft(Eplus(:,y,z,t)));
        end
    end
end
if param.display
    t=param.nt; z=4;
    figure('Name','Eplus')
    subplot(1,2,1); imagesc(abs(Eplus(:,:,z,t))); title('Eplus')
    subplot(1,2,2); imagesc(abs(fftEplus(:,:,z,t))); title('fftEplus')
end

% 8. Subtract the reference phase obtained in (4)
disp('8. Subtract the reference phase obtained in (4)');
Estarplusphase = angle(fftEplus) - repmat(Pplus,[1 1 1 size(fftEplus,4)]);
a = real(abs(fftEplus).*cos(Estarplusphase));
b = real(abs(fftEplus).*sin(Estarplusphase));
ksP = complex(a,b);
if param.display
    z=4; t=4;
    figure
    subplot(1,2,1); imagesc(abs(fftEplus(:,:,z,t))); title('Eplus')
    subplot(1,2,2); imagesc(abs(ksP(:,:,z,t))); title('Estarplus')
end

% Set the background phase to 0
% mean_Estarplus = mean(abs(Estarplus(:)));
% EstarPlus(abs(Estarplus)<mean_Estarplus) = 0;

% 9. FT along the phase dimension
disp('9. FT along the phase dimension');
for t=1:param.nt
    for z=1:param.knz
        for x=1:param.knx
            rsP_full(x,:,z,t) = (fftshift(ifft(ksP(x,:,z,t))));
        end
    end
end

% Eliminating the double sampling in the frequency direction
if param.double_freq_sampling
    rsP=rsP_full(param.knx/4+1:3*param.knx/4,:,:,:);
else 
    rsP=rsP_full;
end

% Centering rspace
if param.center_rspace == 1
    disp('Centering rspace')
    [ksP,rsP] = rspace_centering (ksP,rsP_full,rsP_full,param);
end

% 10. Calculate the magnitude of the image for display
disp('10. Calculate the magnitude of the image for display');
if param.display
    t=4; z=4;
    figure('Name','E')
    subplot(1,2,1); imagesc(abs(fftshift(ksP(:,:,z,t)))); title('Estarplus')
    subplot(1,2,2); imagesc(abs(rsP(:,:,z,t))); title('fftE')
    colormap gray
end

%% Display data_fdf and data_fid
if param.fdf_comp && param.display
    disp('Display data_fdf and data_fid')
    display_function(data_fdf,rsP,'Varian','pointwise');
end

%% Save in .nii
if param.save_nii
    [pathstr, name, ext] = fileparts(fid_file);
    output_dir=[pathstr filesep name '_recon.nii' filesep];
    if ~exist(output_dir,'dir')
        mkdir(output_dir);
    end
    output_file=[output_dir 'pointwise.nii'];
    output_file_rs_phase=[output_dir 'pointwise_phase.nii'];
    try
        disp(['Writing ' output_file])
        aedes_write_nifti(abs(rsP),output_file);
        if param.outputphase
            disp(['Writing ' output_file_rs_phase])
            aedes_write_nifti(angle(rsP),output_file_rs_phase);
        end
    catch exception
        errordlg(['unable to write ' output_file])
    end
end
disp('done')

