function [fftxksP,fftxksN,rsP,rsN] = kspace_reading_xcorr(raw_data_fid,fid_file,param)
%% kspace_reading_xcorr
% This function reads the kspace of an EPIP experiment from a .fid varian
% file. It then performs the correction of the kspace with a cross
% correlation algorithm to correct the odd and even echoes mismatch.
% Finally, it performs a fourier transform to obtain the real space image.
% It can then compare those images to the .fid generated by varian and/or
% save the images in a .nii file.

% param fields (default value):
% param.data (1): specifies if the data used should be the raw Eplus and Eminus
% images or the intertwined images IprimeP and IprimeN

% param.save_nii (1): specifies if the data should be saved in a .nii files

% param.correction (1): specifies the type of correlation to be used.
% 1: Correct odd and even echoes mismatch with the central columns of each scan
% 2: Correct odd and even echoes mismatch with the 2 most correlated odd/even columns of each scan
% 3: Correct odd and even echoes mismatch individually for each column

% param.center_kspace (2): specifies the type of kspace centering to be
% applied before the cross correlation
% 0: no centering
% 1: 1D centering (only in the frequency direction)
% 2: 2D centering

% param.nx (64): Must specify the number of lines in the frequency direction

% param.ny (64): Must specify the number of lines in the phase direction

% param.display (1): Specifies if the data should be displayed or not

% param.fdf_comp (1): Specifies if the fdf data should be readed and
% compared

% param.vol_pour (1): specifies the pourcentage of volumes to be
% kept and analysed. 1=all the volumes. 0=only the first volume

%% Parameter verification
if ~exist(fid_file,'file')
    errordlg('Cannot find the fid_file')
end
% field_names={'data','save_nii','correction','center_kspace','nx','ny','display','fdf_comp' 'vol_pour'};
% default_values=[1 1 1 2 64 64 1 1 1];
% field_verif = isfield(param,field_names);
% if ~isempty(find(field_verif,1));
%     default_fields = find(field_verif==0);
%     for i=default_fields
%         param.(field_names{i})=default_values(i);
%     end
% end

%% Computing IprimeP and IprimeN
if param.data==1
    disp('Computing IprimeP and IprimeN')
    IprimeP = zeros(param.knx,param.ny,param.knz,param.nt);
    IprimeP(:,1:2:param.ny-1,:,:) = raw_data_fid.Eplus(:,1:2:param.ny-1,:,:);
    IprimeP(:,2:2:param.ny,:,:) = raw_data_fid.Eminus(:,2:2:param.ny,:,:);
    Rplus(:,1:2:param.ny-1,:) = raw_data_fid.Rplus(:,1:2:param.ny-1,:);
    Rplus(:,2:2:param.ny,:,:) = raw_data_fid.Rminus(:,2:2:param.ny,:,:);
    
    IprimeN = zeros(param.knx,param.ny,param.knz,param.nt);
    IprimeN(:,1:2:param.ny-1,:,:) = raw_data_fid.Eminus(:,1:2:param.ny-1,:,:);
    IprimeN(:,2:2:param.ny,:,:) = raw_data_fid.Eplus(:,2:2:param.ny,:,:);
    Rminus(:,1:2:param.ny-1,:,:) = raw_data_fid.Rminus(:,1:2:param.ny-1,:,:);
    Rminus(:,2:2:param.ny,:) = raw_data_fid.Rplus(:,2:2:param.ny,:);
    for z=1:param.knz
        for t=1:param.nt
            fftIprimeP(:,:,z,t) = fftshift(fft2(IprimeP(:,:,z,t)));
            fftIprimeN(:,:,z,t) = fftshift(fft2(IprimeN(:,:,z,t)));
        end
    end
elseif param.data==0
    disp('Using the raw scans Eplus and Eminus')
    IprimeP = zeros(param.knx,param.ny,param.knz,param.nt);
    IprimeP(:,1:2:param.ny-1,:,:) = raw_data_fid.Eplus(:,1:2:param.ny-1,:,:);
    IprimeP(:,2:2:param.ny,:,:) = raw_data_fid.Eplus(end:-1:1,2:2:param.ny,:,:);
    Rplus(:,1:2:param.ny-1,:) = raw_data_fid.Rplus(:,1:2:param.ny-1,:);
    Rplus(:,2:2:param.ny,:) = raw_data_fid.Rplus(end:-1:1,2:2:param.ny,:);
    
    IprimeN = zeros(param.knx,param.ny,param.knz,param.nt);
    IprimeN(:,1:2:param.ny-1,:,:) = raw_data_fid.Eminus(end:-1:1,1:2:param.ny-1,:,:);
    IprimeN(:,2:2:param.ny,:,:) = raw_data_fid.Eminus(:,2:2:param.ny,:,:);
    Rminus(:,1:2:param.ny-1,:) = raw_data_fid.Rminus(end:-1:1,1:2:param.ny-1,:);
    Rminus(:,2:2:param.ny,:) = raw_data_fid.Rminus(:,2:2:param.ny,:);
    for z=1:param.knz
        for t=1:param.nt
            fftIprimeP(:,:,z,t) = fftshift(fft2(IprimeP(:,:,z,t)));
            fftIprimeN(:,:,z,t) = fftshift(fft2(IprimeN(:,:,z,t)));
        end
    end
end

% Display IprimeP and IprimeN
if param.display
    z=round(param.knz/2); t=param.nt;
    figure(1)
    %     for z=1:param.knz
    subplot(2,4,1); imagesc(log(abs(raw_data_fid.Eplus(:,:,z,t)))); title('abs Eplus')
    subplot(2,4,2); imagesc(log(abs(IprimeP(:,:,z,t)))); title('abs IprimeP')
    subplot(2,4,3); imagesc(angle(IprimeP(:,:,z,t))); title('angle IprimeP')
    subplot(2,4,4); imagesc(abs(fftIprimeP(:,:,z,t))); title('fftIprimeP')
    subplot(2,4,5); imagesc(log(abs(raw_data_fid.Eminus(:,:,z,t)))); title('abs Eminus')
    subplot(2,4,6); imagesc(log(abs(IprimeN(:,:,z,t)))); title('abs IprimeN')
    subplot(2,4,7); imagesc(angle(IprimeN(:,:,z,t))); title('angle IprimeN')
    subplot(2,4,8); imagesc(abs(fftIprimeN(:,:,z,t))); title('fftIprimeN')
    % pause;
    %     end
    figure(2)
    subplot(2,2,1); imagesc((abs(Rplus(:,:,z)))); title('abs Rplus')
    subplot(2,2,2); imagesc((angle(Rplus(:,:,z)))); title('angle Rplus')
    subplot(2,2,3); imagesc((abs(Rminus(:,:,z)))); title('abs Rminus')
    subplot(2,2,4); imagesc((angle(Rminus(:,:,z)))); title('angle Rminus')
end
clear Eplus Eminus

%% Navigator images extraction
if param.navigator
    param.norm_factor=1;
    if param.data==1
        navi.P_odd = squeeze(raw_data_fid.navi.Eplus(:,1,:,:));
        navi.P_even = squeeze(raw_data_fid.navi.Eminus(:,2,:,:));
        if param.negative_image
            navi.N_odd = squeeze(raw_data_fid.navi.Eminus(:,1,:,:));
            navi.N_even = squeeze(raw_data_fid.navi.Eplus(:,2,:,:));
        end
    elseif param.data==0
        navi.P_odd = squeeze(raw_data_fid.navi.Eplus(:,1,:,:));
        navi.P_even = squeeze(raw_data_fid.navi.Eplus(end:-1:1,2,:,:));
        if param.negative_image
            navi.N_odd = squeeze(raw_data_fid.navi.Eminus(:,1,:,:));
            navi.N_even = squeeze(raw_data_fid.navi.Eminus(end:-1:1,2,:,:));
        end
    end
    param.inc = 0.01;
    param.gauss_1D = fspecial('gaussian',[round(param.knx/10),1],round(param.knx/20));
    for t=1:param.nt
        for z=1:param.nz
            navi.P_odd_max(z,t) = precise_max(navi.P_odd(:,z,t),param);
            navi.P_even_max(z,t) = precise_max(navi.P_even(:,z,t),param);
            navi.P_odd_smooth(:,z,t) = imfilter(navi.P_odd(:,z,t),param.gauss_1D);
            navi.P_even_smooth(:,z,t) = imfilter(navi.P_even(:,z,t),param.gauss_1D);
            navi.P_odd_smooth_max(z,t) = precise_max(navi.P_odd_smooth(:,z,t),param);
            navi.P_even_smooth_max(z,t) = precise_max(navi.P_even_smooth(:,z,t),param);
            if param.negative_image
                navi.N_odd_max(z,t) = precise_max(navi.N_odd(:,z,t),param);
                navi.N_even_max(z,t) = precise_max(navi.N_even(:,z,t),param);
                navi.N_odd_smooth(:,z,t) = imfilter(navi.N_odd(:,z,t),param.gauss_1D);
                navi.N_even_smooth(:,z,t) = imfilter(navi.N_even(:,z,t),param.gauss_1D);
                navi.N_odd_smooth_max(z,t) = precise_max(navi.N_odd_smooth(:,z,t),param);
                navi.N_even_smooth_max(z,t) = precise_max(navi.N_even_smooth(:,z,t),param);
            end
        end
    end
    navi.P_odd_even_diff = navi.P_odd_max-navi.P_even_max;
    if param.negative_image
        navi.N_odd_even_diff = navi.N_odd_max-navi.N_even_max;
    end
    if param.display
        for z=1:param.knz
            figure
            subplot(2,1,1); imagesc(squeeze(abs(navi.P_odd(:,z,:)))); title(['Odd navigator z=' num2str(z)])
            subplot(2,1,2); plot(navi.P_odd_max(z,:)); axis tight; title('maximum')
            %         subplot(3,1,3); plot(navi.P_odd_smooth_max(:,z)); axis tight; title('maximum of smoothed nav')
        end
        for z=1:param.knz
            figure
            subplot(2,1,1); imagesc(squeeze(abs(navi.P_even(:,z,:)))); title(['Even navigator z=' num2str(z)])
            subplot(2,1,2); plot(navi.P_even_max(z,:)); axis tight; title('maximum')
            %         subplot(3,1,3); plot(navi.P_even_smooth_max(:,z)); axis tight; title('maximum of smoothed nav')
        end
        figure
        for z=1:param.knz
            subplot(2,param.knz/2,z); plot(navi.P_odd_even_diff(z,:)); title(['difference  z=' num2str(z)])
        end
    end
end
clear raw_data_fid

%% Center kspace
[IprimePc,IprimeNc,param] = center_kspace(IprimeP,IprimeN,param);
clear IprimeP IprimeN

%% Odd and even echoes mismatch correction
disp(['Correcting odd and even echoes mismatch with xcorr_type = ' num2str(param.correction)])
param.inc=0.01;
if param.correction==1
    %% Correct odd and even echoes mismatch with the central columns of each scan using cross_correlation of multiple central columns
    disp('Correct odd and even echoes mismatch with the central columns of each scan using cross_correlation of multiple central columns')
    % Define the columns to be used
    param.odd_columns = round(3*param.ny/8)+1:2:round(5*param.ny/8)+1;
    param.even_columns = round(3*param.ny/8):2:round(5*param.ny/8);
    param.gauss_1D = fspecial('gaussian',[round(param.knx/3),1],round(param.knx/6));
    ksP=IprimePc;
    if param.fourier2D==0
        for t=1:param.nt
            for z=1:param.knz
                for y=1:param.ny
                    fftxksP(:,y,z,t) = fftshift(ifft(ksP(:,y,z,t)));
                end
            end
        end
    elseif param.fourier2D==1
        fftxksP=IprimePc;
    end
    [fftxksP] = xcorr_correction1 (fftxksP,param);
    
    if param.negative_image
        ksN=IprimeNc;
        if param.fourier2D==0
            for t=1:param.nt
                for z=1:param.knz
                    for y=1:param.ny
                        fftxksN(:,y,z,t) = fftshift(ifft(ksN(:,y,z,t)));
                    end
                end
            end
        elseif param.fourier2D==1
            fftxksN=IprimeNc;
        end
        [fftxksN] = xcorr_correction1 (fftxksN,param);
    else
        fftxksN=IprimeNc;
    end
    
elseif param.correction==2
    %% Correct odd and even echoes mismatch with the 2 most correlated odd/even columns of each scan using cross_correlation
    disp('Correct odd and even echoes mismatch with the 2 most correlated odd/even columns of each scan using cross_correlation')
    param.central_position = param.knx/2;
    param.gauss_1D = fspecial('gaussian',[round(param.knx/10),1],round(param.knx/20));
    ksP=IprimePc;
    if param.fourier2D==0
        for t=1:param.nt
            for z=1:param.knz
                for y=1:param.ny
                    fftxksP(:,y,z,t) = fftshift(ifft(ksP(:,y,z,t)));
                end
            end
        end
    elseif param.fourier2D==1
        fftxksP=IprimePc;
    end
    [fftxksP] = xcorr_correction2(fftxksP,param);
    
    if param.negative_image
        ksN=IprimeNc;
        if param.fourier2D==0
            for t=1:param.nt
                for z=1:param.knz
                    for y=1:param.ny
                        fftxksN(:,y,z,t) = fftshift(ifft(ksN(:,y,z,t)));
                    end
                end
            end
        elseif param.fourier2D==1
            fftxksN=IprimeNc;
        end
        [fftxksN] = xcorr_correction2(fftxksN,param);
    else
        fftxksN=IprimeNc;
    end
elseif param.correction==3
    %% Correct odd and even echoes mismatch individually for each column
    disp('Correct odd and even echoes mismatch individually for each column')
    ksP=IprimePc;
    param.central_position = param.knx/2;
    param.gauss_1D = fspecial('gaussian',[round(param.knx/10),1],round(param.knx/20));
    param.columns_to_correct=param.ny/4:2:3*param.ny/4;
    if param.fourier2D==0
        for t=1:param.nt
            for z=1:param.knz
                for y=1:param.ny
                    fftxksP(:,y,z,t) = fftshift(ifft(ksP(:,y,z,t)));
                end
            end
        end
    elseif param.fourier2D==1
        fftxksP=IprimePc;
    end
    [fftxksP] = xcorr_correction3(fftxksP,param);
    
    if param.negative_image
        ksN=IprimeNc;
        if param.fourier2D==0
            for t=1:param.nt
                for z=1:param.knz
                    for y=1:param.ny
                        fftxksN(:,y,z,t) = fftshift(ifft(ksN(:,y,z,t)));
                    end
                end
            end
        elseif param.fourier2D==1
            fftxksN=IprimeNc;
        end
        [fftxksN] = xcorr_correction3(fftxksN,param);
    else
        fftxksN=IprimeNc;
    end
    
elseif param.correction==4
    %% Odd and even echoes mismatch correction using the cross correlation on the reference scans
    disp('Odd and even echoes mismatch correction using the reference scans')
    param.central_position = param.knx/2;
    ksP=IprimePc;
    RsP = Rplus;
    if param.fourier2D==0
        for z=1:param.knz
            for y=1:param.ny
                fftxRsP(:,y,z) = fftshift(ifft(RsP(:,y,z)));
                for t=1:param.nt
                    fftxksP(:,y,z,t) = fftshift(ifft(ksP(:,y,z,t)));
                end
            end
        end
    elseif param.fourier2D==1
        fftxksP=IprimePc;
        fftxRsP=Rplus;
    end
    [fftxksP,fftxRsP] = xcorr_correction4(fftxksP,fftxRsP,param);
    
    if param.negative_image
        ksN=IprimeNc;
        RsN = Rminus;
        if param.fourier2D==0
            for z=1:param.knz
                for y=1:param.ny
                    fftxRsN(:,y,z) = fftshift(ifft(RsN(:,y,z)));
                    for t=1:param.nt
                        fftxksN(:,y,z,t) = fftshift(ifft(ksN(:,y,z,t)));
                    end
                end
            end
        elseif param.fourier2D==1
            fftxksN=IprimeNc;
            fftxRsN=Rminus;
        end
        [fftxksN,fftxRsN] = xcorr_correction4(fftxksN,fftxRsN,param);
    else
        fftxksN=IprimeNc;
    end
    
elseif param.correction==5
    %% Global phase correction with linear interpolation on the reference scans
    disp('Global phase correction with linear interpolation on the reference scans')
    ksP = IprimePc;
    [fftxksP,Rplus] = xcorr_correction5(ksP,Rplus,param);
    
    if param.negative_image
        ksN = IprimeNc;
        [fftxksN,Rminus] = xcorr_correction5(ksN,Rminus,param);
    else
        fftxksN=IprimeNc;
    end
    
elseif param.correction==6
    %% Odd and even correction mismatch + global phase correction with linear interpolation using the reference scans (correction 4+5)
    disp('Odd and even correction mismatch + global phase correction with linear interpolation using the reference scans (correction 4+5)')
    param.inc=0.01;
    param.central_position = param.knx/2;
    ksP = IprimePc;
    RsP = Rplus;
    [ksP,RsP] = xcorr_correction4(ksP,RsP,param);
    [fftxksP,Rplus] = xcorr_correction5(ksP,RsP,param);
    
    if param.negative_image
        ksN = IprimeNc;
        RsN = Rminus;
        [ksN,RsN] = xcorr_correction4(ksN,RsN,param);
        [fftxksN,Rminus] = xcorr_correction5(ksN,RsN,param);
    else
        fftxksN=IprimeNc;
    end
    
elseif param.correction==7 && param.navigator ==1
    %% Navigator correction
    disp('Odd and even correction mismatch + Global phase correction with linear interpolation on the navigator scans')
    ksP = IprimePc;
    navP_odd = navi.P_odd;
    navP_even = navi.P_even;
    fftxksP = xcorr_navigator(ksP,navP_odd,navP_even,param);
    
    if param.negative_image
        ksN = IprimeNc;
        navN_odd = navi.N_odd;
        navN_even = navi.N_even;
        fftxksN = xcorr_navigator(ksN,navN_odd,navN_even,param);
    else
        fftxksN=IprimeNc;
    end
    
elseif param.correction==8 && param.navigator==1
    %% Navigator correction
    disp('Odd and even correction mismatch (xcorr1) + Global phase correction with linear interpolation on the navigator scans')
    navP_odd = navi.P_odd;
    navP_even = navi.P_even;
    param.odd_columns = 1;
    param.even_columns = 2;
    param.gauss_1D = fspecial('gaussian',[round(param.knx/3),1],round(param.knx/6));
    
    ksP=IprimePc;
    navP_odd_perm = permute(shiftdim(navP_odd,-1),[2 1 3 4]);
    navP_even_perm = permute(shiftdim(navP_even,-1),[2 1 3 4]);
    navP = [navP_odd_perm navP_even_perm];
    [navP_xcorr] = xcorr_correction1 (navP,param);
    navP_odd = squeeze(navP_xcorr(:,1,:,:));
    navP_even = squeeze(navP_xcorr(:,2,:,:));
    fftxksP = xcorr_navigator(ksP,navP_odd,navP_even,param);
    
    if param.negative_image
        ksN = IprimeNc;
        navN_odd = navi.N_odd;
        navN_even = navi.N_even;
        fftxksN = xcorr_navigator(ksN,navN_odd,navN_even,param);
    else
        fftxksN=IprimeNc;
    end
    
elseif param.correction==9
    %% Global phase correction with linear interpolation using the average kspace
    disp('Global phase correction with linear interpolation using the average scans (correction 5 with average kspace)')
    ksP = IprimePc;
    mean_IprimePc = mean(IprimePc,4);
    [fftxksP,Rplus] = xcorr_correction5(ksP,mean_IprimePc,param);
    
    if param.negative_image
        ksN = IprimeNc;
        mean_IprimeNc = mean(IprimeNc,4);
        [fftxksN,Rminus] = xcorr_correction5(ksP,mean_IprimeNc,param);
    else
        fftxksN=IprimeNc;
    end
    
elseif param.correction == 10
    %% Individual global phase correction with linear interpolation on each scan
    disp('Individual global phase correction with linear interpolation on each scan')
    ksP = IprimePc;
    [fftxksP] = xcorr_correction8(ksP,param);
    
    if param.negative_image
        ksN = IprimeNc;
        [fftxksN] = xcorr_correction8(ksN,param);
    else
        fftxksN=IprimeNc;
    end
    
elseif param.correction==11 && param.navigator==1
    %% Odd and even correction mismatch + global phase correction with linear interpolation using the reference scans (correction 4+5) + navigator intensity correction
    disp('Odd and even correction mismatch + global phase correction with linear interpolation using the reference scans (correction 4+5) + navigator intensity correction')
    param.inc=0.01;
    param.central_position = param.knx/2;
    ksP = IprimePc;
    RsP = Rplus;
    [ksP,RsP] = xcorr_correction4(ksP,RsP,param);
    [fftxksP,Rplus] = xcorr_correction5(ksP,RsP,param);
    
    % Navigator intensity correction
    navP_odd = navi.P_odd;
    navP_even = navi.P_even;
    param.odd_columns = 1;
    param.even_columns = 2;
    param.gauss_1D = fspecial('gaussian',[round(param.knx/3),1],round(param.knx/6));
    
    navP_odd_perm = permute(shiftdim(navP_odd,-1),[2 1 3 4]);
    navP_even_perm = permute(shiftdim(navP_even,-1),[2 1 3 4]);
    navP = [navP_odd_perm navP_even_perm];
    [navP_xcorr] = xcorr_correction1 (navP,param);
    navP_odd = squeeze(navP_xcorr(:,1,:,:));
    navP_even = squeeze(navP_xcorr(:,2,:,:));
    fftxksP = navigator_intensity_correction(fftxksP,navP_odd,navP_even,RsP,param);
    
    if param.negative_image
        ksN = IprimeNc;
        RsN = Rminus;
        [ksN,RsN] = xcorr_correction4(ksN,RsN,param);
        [fftxksN,Rminus] = xcorr_correction5(ksN,RsN,param);
        
        navN_odd_perm = permute(shiftdim(navN_odd,-1),[2 1 3 4]);
        navN_even_perm = permute(shiftdim(navN_even,-1),[2 1 3 4]);
        navN = [navN_odd_perm navN_even_perm];
        [navN_xcorr] = xcorr_correction1 (navN,param);
        navN_odd = squeeze(navN_xcorr(:,1,:,:));
        navN_even = squeeze(navN_xcorr(:,2,:,:));
        fftxksN = navigator_intensity_correction(fftxksN,navP_odd,navN_even,RsN,param);
    else
        fftxksN=IprimeNc;
    end
    
else
    %% No correction
    ksP=IprimePc;
    ksN=IprimeNc;
    RsP=Rplus;
    RsN=Rminus;
    if param.fourier2D==0
        for z=1:param.knz
            for y=1:param.ny
                fftxRsP(:,y,z) = fftshift(ifft(Rplus(:,y,z)));
                fftxRsN(:,y,z) = fftshift(ifft(Rminus(:,y,z)));
                for t=1:param.nt
                    fftxksP(:,y,z,t) = fftshift(ifft(ksP(:,y,z,t)));
                    fftxksN(:,y,z,t) = fftshift(ifft(ksN(:,y,z,t)));
                end
            end
        end
    elseif param.fourier2D==1
        fftxksP=IprimePc;
        fftxksN=IprimeNc;
        fftxRsP=Rplus;
        fftxRsN=Rminus;
    end
end
clear IprimePc IprimeNc Rplus Rminus

%% ifft
disp('Computing rspace')
if param.fourier2D==1 && param.correction<5
    for z=1:param.knz
        for t=1:param.nt
            rsP_full(:,:,z,t) = (fftshift(ifft2(fftxksP(:,:,z,t))));
            rsN_full(:,:,z,t) = (fftshift(ifft2(fftxksN(:,:,z,t))));
        end
    end
else
    for z=1:param.knz
        for t=1:param.nt
            for x=1:param.knx
                rsP_full(x,:,z,t) = (fftshift(ifft(fftxksP(x,:,z,t))));
                rsN_full(x,:,z,t) = (fftshift(ifft(fftxksN(x,:,z,t))));
            end
        end
    end
end

%% Eliminating the double sampling in the frequency direction
if param.double_freq_sampling
    rsP=rsP_full(param.knx/4+1:3*param.knx/4,:,:,:);
    rsN=rsN_full(param.knx/4+1:3*param.knx/4,:,:,:);
else
    rsP=rsP_full;
    rsN=rsN_full;
end

%% Normalizating values between 0 and 1
% rsP = rsP/max(max(max(max(rsP))));
% rsN = rsN/max(max(max(max(rsN))));

%% Centering rspace
if param.center_rspace == 1
    disp('Centering rspace')
    [fftxksP,rsP] = rspace_centering (fftxksP,rsP_full,rsP_full,param);
    [fftxksN,rsN] = rspace_centering (fftxksN,rsN_full,rsN_full,param);
end

%% Display kspace and rspace
if param.display
    figure
    display_function(ksP,rsP,ksN,rsN,'ksP','rsP','ksN','rsN')
end

%% Save in .nii
if param.save_nii
    [pathstr, name, ext] = fileparts(fid_file);
    output_dir=[pathstr filesep name '_recon.nii' filesep];
    if ~exist(output_dir,'dir')
        mkdir(output_dir);
    end
    output_file_rs=[output_dir 'rs_xcorr_type' num2str(param.correction) '.nii'];
    output_file_rs_phase=[output_dir 'rs_xcorr_type' num2str(param.correction) '_phase.nii'];
    %     output_file_ks=[output_dir 'ks_xcorr_type' num2str(param.correction) '.nii'];
    try
        disp(['Writing ' output_file_rs])
        aedes_write_nifti(abs(rsP),output_file_rs);
        if param.outputphase
            disp(['Writing ' output_file_rs_phase])
            aedes_write_nifti(angle(rsP),output_file_rs_phase);
        end
        %         disp(['Writing ' output_file_ks])
        %         aedes_write_nifti(data_kspace,output_file_ks);
    catch exception
        errordlg(['unable to write ' output_file_rs])
    end
end
disp('done')